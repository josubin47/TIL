# 놓쳤던 작은 것들
따로 빼서 정리하기 애매한 것들 모아서 정리.

## 시맨틱한 코드 작성의 중요성
나중에 차차 자세히 정리 예정.

## Number 형변환 return값
- true : 0
- false : 1
- null : +0

## +value, -value
값 앞에 +, - 부호를 붙이면 숫자가 되는데 연산할 때만 바꾸고 원래 값은 바꾸지 않는다.

## 유니코드
코드포인트는 유니코드를 등록할 때 부여된다. 값은 유니코드 등록 순서로 비교된다.

```jsx
“가” > “다” //false
```

## strict 모드

ES5부터 지원된다. "use strict" 작성은 필수?

엄격하게 JS 문법을 사용하겠다는 선언. 작성한 위치부터 적용된다.

## label문

반복문 제어를 위한 이름표.

```jsx
break 라벨명;
continue 라벨명;
```

💬 왜 사용하지 않을까?

👉 현재 실행하는 코드에서 label로 직접 이동하는 것은 goto문을 사용하는 것과 같다. 반복이 끝나면 아래로 내려가게 되므로 코드의 가독성을 확보할 수 있지만 코드 흐름이 엉킬 수 있다. 함수에서 다른 함수를 호출했을 때, 호출된 함수의 실행이 끝나면 호출한 함수로 돌아오는 형태가 되어야 코드 흐름이 엉키지 않는다. label은 이런 흐름을 깨뜨릴 수 있다.

## for~in문

ES3에서는 프로퍼티를 작성한 순서대로 읽여진다는 것을 보장하지 않지만, ES5부터는 순서를 보장한다.

```jsx
//for (변수 or 표현식 in Object)
for(var item in obj){}
```

## new 연산자

오브젝트로 인스턴스를 생성하여 반환. 원본을 복사하는 개념.

```jsx
let obj = new Number();
log(typeof obj); //object
```

왜 인스턴스를 만들까? 👉 인스턴스마다 값을 갖게 하기 위해서.

## Primitive Value

언어에 있어 가장 낮은 단계의 값.

```jsx
let book = "책"; //"책"은 더이상 분해, 전개 불가능
```

Number, String, Boolean : 인스턴스 생성 가능

Null, Undefined : 인스턴스 생성 불가

Object : 프리미티브 값을 제공하지 않음

인스턴스를 생성하면 파라미터 값을 인스턴스의 프리미티브 값으로 설정한다.

프리미티브 값을 갖는 오브젝트 : Boolean, Date, Number, String

```jsx
let obj = new Number(123);
log(obj + 200); //323
```

> 123을 인스턴스의 프리미티브 값으로 설정하기 때문에 연산이 가능하다.

## typeof의 한계
```jsx
log(typeof null); //object
```

