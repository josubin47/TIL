# JS 코드를 어떻게 작성할 것인가

## 객체 속성의 순서

객체 속성을 항상 같은 순서로 초기화해서 히든 클래스 및 이후에 생성되는 최적화 코드가 공유될 수 있도록 한다.

## 동적 속성

객체 생성 이후에 속성을 추가하는 것은 히든 클래스가 변하도록 강제하고 이전의 히든 클래스를 대상으로 최적화되었던 모든 메소드를 느리게 만든다. 모든 객체 멤버는 생성자 함수 안에서 초기화 한다.

## 메소드

동일한 메소드를 반복적으로 수행하는 코드가 서로 다른 메소드를 한 번씩만 수행하는 코드보다 더 빠르게 동작한다. ([인라인 캐싱](https://www.notion.so/JS-Google-V8-9ea64beb2ce04be3b97c8b9135e30b8c))

## 일반 배열

배열의 요소들은 접근할 때 많은 비용이 든다. 배열 저장소가 한 유형에서 다른 유형으로 변경되지 않게한다.

- 인덱스 0부터 시작하는 연속키 사용
- 숫자 배열의 요소를 삭제하지 않는다
- 초기화하지 않은 요소는 호출하지 않는다.
- 배열의 요소를 삭제하지 않는다. 그 배열의 키가 띄엄띄엄 배치된다.
- 커다란 배열을 미리 할당하는 것보다는 사용하면서 크기가 커지도록 하는 게 낫다.

## Double 배열

double 타입 배열은 일반 배열보다 빠르다. 히든 클래스는 요소의 타입을 검사하여 히든 클래스를 변경하는 작업이 있으나 double의 경우 여기서 제외된다.

- 초기화시 배열 리터럴을 이용하여 배열 크기를 작게 고정한다.
- 사용하기 전 크기에 맞게 배열 사이즈를 할당한다.
- 숫자 배열에 숫자가 아닌 값 사용은 자제한다.
- 리터럴을 사용하지 않고 배열을 초기화할 때 작은 배열이 재변환 되지 않도록 주의한다.

```jsx
// 비효율적인 코드
var a = new Array();
a[0] = 77;    // 할당
a[1] = 88;
a[2] = 0.5;   // 할당, 배열 타입 변환 (일반배열 -> double 배열)
a[3] = true;  // 할당, 배열 타입 변환 (double 배열 -> 일반배열)

// 효율적인 코드
var a = [77, 88, 0.5, true];
```

> 한 번에 선언하면 컴파일러가 요소의 타입을 모두 알고 히든 클래스를 미리 결정할 수 있다. 불필요한 전환 작업을 줄이자.
> 

## Number

number 타입을 지속적으로 쓰는 것이 중요. 31비트 부호있는 정수를 사용.

## 단형적 연산

```jsx
function add(x, y) {
  return x + y;
}

add(1, 2);      // add 함수의 더하기는 단형적 연산입니다.
add("a", "b");  // add 함수의 더하기는 다형적 연산이 됩니다.
```

> 같은 함수에 대한 두 번의 호출이 동일한 히든 클래스를 쓰는 것이 아니고 달라지기 때문에 다형적 연산이 됨.
> 

## try~catch

try catch 문 사용 시 성능에 민감한 코드는 내장함수에 적용한다.

```jsx
function perf_sensitive() {
    // Do performance-sensitive work here
  }

  try {
    perf_sensitive()
  } catch (e) {
    // Handle exceptions here
  }
```

## 함수가 최적화 된 이후에는 [히든 클래스](https://www.notion.so/JS-Google-V8-9ea64beb2ce04be3b97c8b9135e30b8c) 변경을 자제